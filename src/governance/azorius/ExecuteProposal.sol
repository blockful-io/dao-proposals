// SPDX-License-Identifier: MIT
pragma solidity >=0.8.25 <0.9.0;

import { Test } from "forge-std/src/Test.sol";
import { console2 } from "forge-std/src/console2.sol";

import "@shutter/interfaces/IAzorius.sol";

contract ExecuteProposal is Test {
    /**
     * @dev Executes a proposal in the Azorius contract.
     *
     * Walkthrough:
     * 1. Prank the executor of the proposal
     * 2. Prepare the transactions to be executed
     * 3. Execute the proposal {Azorius-executeProposal}
     * 4. Stops the prank
     *
     * @param prank The address that will be impersonated.
     * @param governor The Azorius contract address.
     * @param proposalId The proposal ID to execute.
     * @param transactions The transactions to be executed.
     */
    function executeProposal(
        address prank,
        address governor,
        uint32 proposalId,
        IAzorius.Transaction[] memory transactions
    )
        public
    {
        // Prank the executor of the proposal
        vm.startPrank(prank);
        // Prepare the transactions to be executed. Same data as submit Proposal but
        // we need to break them apart and join the similar types
        (address[] memory targets, uint256[] memory values, bytes[] memory data, IAzorius.Operation[] memory operations)
        = _prepareTransactionsForExecution(transactions);
        // Execute the proposal {Azorius-executeProposal}
        IAzorius(governor).executeProposal(proposalId, targets, values, data, operations);
        // Stops the prank
        vm.stopPrank();
    }

    /**
     * @dev Prepares the transactions to be executed in the proposal.
     * @param transactions The transactions submited in the proposal generated by {_prepareTransactionsForProposal}
     * @return targets The addresses of the contracts to be called.
     * @return values The amount of ETH to be sent to the contracts.
     * @return data The encoded calldata to be sent to the contracts.
     * @return operations The type of operation to be executed in the contracts. Call or DelegateCall.
     */
    function _prepareTransactionsForExecution(IAzorius.Transaction[] memory transactions)
        internal
        pure
        returns (
            address[] memory targets,
            uint256[] memory values,
            bytes[] memory data,
            IAzorius.Operation[] memory operations
        )
    {
        uint256 transactionsLength = transactions.length;

        targets = new address[](transactionsLength);
        values = new uint256[](transactionsLength);
        data = new bytes[](transactionsLength);
        operations = new IAzorius.Operation[](transactionsLength);

        for (uint256 i = 0; i < transactions.length; i++) {
            targets[i] = transactions[i].to;
            values[i] = transactions[i].value;
            data[i] = transactions[i].data;
            operations[i] = transactions[i].operation;
        }
    }
}
